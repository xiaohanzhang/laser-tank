{"version":3,"sources":["features/game/tiles.ts","features/game/game.ts","features/game/consts.ts","features/game/files.ts","features/game/Board.tsx","features/ui/MenuBar.tsx","features/ui/ui.ts","features/ui/ControlPanel.tsx","app/App.tsx","serviceWorker.ts","app/rootReducer.ts","app/store.ts","index.tsx"],"names":["GameBackgrounds","GameObstacles","CMD","sameCoord","p1","p2","x","y","getDirection","UP","DOWN","LEFT","RIGHT","reverseDirection","direction","fireLasert","game","laser","force","tank","status","isAvailable","position","board","target","get","object","nextPosition","GameObject","css","from","to","beforeCheckPending","pending","push","range","BOARD_SIZE","map","background","DIRT","FLAG","Flag","Dirt","WATER","Water","MOVABLE_BLOCK_WATER","MovableBlockWater","ICE","Ice","THIN_ICE","ThinIce","TANK_MOVER_N","TankMoverN","TANK_MOVER_S","TankMoverS","TANK_MOVER_E","TankMoverE","TANK_MOVER_W","TankMoverW","TUNNEL","Tunnel","obstacle","BRICKS","Bricks","SOLID_BLOCK","SolidBlock","CRYSTAL_BLOCK","CrystalBlock","MOVABLE_BLOCK","MovableBlock","ANTI_TANK_N","AntiTankN","ANTI_TANK_S","AntiTankS","ANTI_TANK_W","AntiTankW","ANTI_TANK_E","AntiTankE","ANTI_TANK_DEAD_N","AntiTankDeadN","ANTI_TANK_DEAD_S","AntiTankDeadS","ANTI_TANK_DEAD_W","AntiTankDeadW","ANTI_TANK_DEAD_E","AntiTankDeadE","MIRROR_NW","MirrorNW","MIRROR_NE","MirrorNE","MIRROR_SE","MirrorSE","MIRROR_SW","MirrorSW","ROTARY_MIRROR_NW","RotaryMirrorNW","ROTARY_MIRROR_NE","RotaryMirrorNE","ROTARY_MIRROR_SE","RotaryMirrorSE","ROTARY_MIRROR_SW","RotaryMirrorSW","tile","this","getBackgroundClass","getObstacleClass","state","getObstacle","handleLaser","checkFire","each","reverse","handlePending","toTile","fromTile","getBackground","handleLeaving","handleLanding","prevBoard","shouldCheckTank","handleTank","callback","forEachTile","current","sawTank","cleanUp","handle","inSkipping","prevTank","rendering","handleTankMove","skipTank","GameObstacle","index","findIndex","p","splice","targetTile","handleMove","dead","dead_direction","directions","indexOf","hitBack","hitMirror","isMoving","find","fire_directions","getFireDirections","includes","checkLaser","next_direction","GameBackground","sameKindTunnel","t1","t2","color","tunnel","pendingTunnel","row","pendingTunnels","obstacleIndex","tankIndex","pedningTile","getNextTarget","moveTank","shouldPending","checkTank","Boolean","saveDataMap","0","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","toString","buffer","String","fromCharCode","apply","Array","Uint8Array","filter","openDataFile","tLevel","levelName","hint","author","scoreDifficulty","sizeOfTLevel","sum","Object","values","Math","floor","byteLength","i","cursor","data","size","key","slice","chunk","Uint16Array","isDirection","cmd","db","record","history","frames","snapshoot","levelIndex","FIRE","fireMap","FIRE_UP","FIRE_DOWN","FIRE_LEFT","FIRE_RIGHT","initialState","createEmptyBoard","timer","pause","positionSaved","frameIndex","levels","gameSlice","createSlice","name","reducers","loadLevels","action","payload","localStorage","setItem","JSON","stringify","caseReducers","loadLevel","level","console","log","join","colors","forEach","cell","j","result","parseBoard","undo","pop","savePosition","restorePosition","setFrame","length","fireTank","renderFrame","checkPending","actions","exec","dispatch","getState","PREV_FRAME","min","NEXT_FRAME","max","UNDO","RESTART","SAVE_POSITION","RESTORE_POSITION","NEXT_LEVEL","PREV_LEVEL","isBoardCMD","save","saveFrame","BoardTile","React","memo","tileSize","style","width","height","className","getBackgroundCss","borderRadius","border","boxSizing","getObstacleCss","BoardRow","directionToStr","Board","props","limit","boardRef","createRef","interval","bindAll","window","addEventListener","handleResize","animations","setInterval","a","el","backgrounds","querySelectorAll","bg","shift","classList","remove","add","removeEventListener","clearInterval","offsetWidth","offsetHeight","setState","nextProps","nextState","tileStyle","ref","letter","display","margin","verticalAlign","lineHeight","left","top","Component","useSelector","ui","useDispatch","debounceRenderFrame","debounce","renderInterval","useEffect","handleKeyDown","e","ARROWUP","ARROWDOWN","ARROWLEFT","ARROWRIGHT","PAUSE","toUpperCase","cancel","useState","currentMenu","setMenu","items","render","id","type","onChange","files","currentTarget","file","reader","FileReader","onload","readAsArrayBuffer","handleFile","onClick","menu","event","offsetTop","offsetLeft","onMouseEnter","uiSlice","setRenderInterval","LevelsPopup","showPopup","setShowPopup","lastCmd","numShoot","numMove","debouncedSetRenderInterval","textAlign","fontSize","disabled","alert","flexDirection","alignItems","flex","value","toNumber","App","parse","getItem","error","location","hostname","match","rootReducer","combineReducers","reducer","store","configureStore","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.23dc449b.chunk.js","sourcesContent":["import { get, each, range, reverse, findIndex } from 'lodash';\nimport {  GameState, DIRECTION, BOARD_SIZE, CMD } from './game';\n\nexport enum GameBackgrounds {\n    // background\n    FLAG = 1,\n    DIRT,\n    WATER,\n    MOVABLE_BLOCK_WATER,\n    ICE,\n    THIN_ICE,\n    TANK_MOVER_N,\n    TANK_MOVER_S,\n    TANK_MOVER_E,\n    TANK_MOVER_W,\n    TUNNEL,\n}\n\nexport enum GameObstacles {\n    // obstacle\n    BRICKS = 32,\n    SOLID_BLOCK = 33,\n    CRYSTAL_BLOCK = 34,\n    MOVABLE_BLOCK = 35,\n    ANTI_TANK_N = 36,\n    ANTI_TANK_S = 37,\n    ANTI_TANK_W = 38,\n    ANTI_TANK_E = 39,\n    ANTI_TANK_DEAD_N = 40,\n    ANTI_TANK_DEAD_S,\n    ANTI_TANK_DEAD_W,\n    ANTI_TANK_DEAD_E,\n    MIRROR_NW,\n    MIRROR_NE,\n    MIRROR_SE,\n    MIRROR_SW,\n    ROTARY_MIRROR_NW,\n    ROTARY_MIRROR_NE,\n    ROTARY_MIRROR_SE,\n    ROTARY_MIRROR_SW,\n}\n\nexport const sameCoord = (p1: Position | null, p2: Position | null): boolean => {\n    return p1 === p2 || (!!p1 && !!p2 && p1.x === p2.x && p1.y === p2.y); \n}\n\n// get direction of p2 relative to p1\nexport const getDirection = (p1: Position, p2: Position): DIRECTION | null => {\n    if (p1.x !== p2.x || p1.y !== p2.y) {\n        if (p1.x === p2.x) {\n            return p1.y > p2.y ? CMD.UP : CMD.DOWN;\n        } else if (p1.y === p2.y) {\n            return p1.x > p2.x ? CMD.LEFT : CMD.RIGHT;\n        }\n    }\n    return null;\n} \n\nconst reverseDirection = (direction: DIRECTION): DIRECTION => {\n    const reverseMap: {[key: string]: DIRECTION} = {\n        [CMD.UP]: CMD.DOWN, \n        [CMD.DOWN]: CMD.UP, \n        [CMD.LEFT]: CMD.RIGHT, \n        [CMD.RIGHT]: CMD.LEFT, \n    };\n    return reverseMap[direction];\n}\n\nconst fireLasert = (game: GameState, laser: Position, force: boolean = false) => {\n    if (game.laser === null || force) {\n        game.laser = laser;\n        // TODO: add this to impelemnt odd/even tank bug\n        if (sameCoord(laser, game.tank)) {\n            game.status = 'FAIL';\n        }\n    }\n}\n\nconst forEachTile = (board: Board, position: Position, callback: (tile: Tile, position: Position) => void | boolean) => {\n    let target = nextPosition(position);\n    while (target.x < BOARD_SIZE && target.y < BOARD_SIZE && target.x >= 0 && target.y >= 0) {\n        if (callback(board[target.y][target.x], target) === false) {\n            break;\n        }\n        target = nextPosition(target);\n    }\n}\n\nexport const isAvailable = (position: Position, board: Board): boolean => {\n    const { x, y } = position;\n    const target = get(board, `${y}.${x}`);\n    return !!(target && !target.object);\n}\n\nexport const nextPosition = (position: Position) => {\n    const { x, y, direction } = position;\n    return {\n        [CMD.UP]: { x, y: y - 1, direction },\n        [CMD.DOWN]: { x, y: y + 1, direction },\n        [CMD.RIGHT]: { x: x + 1, y, direction },\n        [CMD.LEFT]: { x: x - 1, y, direction },\n    }[direction];\n}\n\nexport interface Tile {\n    background: GameBackgrounds,\n    color?: string,\n    object?: GameObstacles,\n};\n\nexport type Board = Tile[][]; \n\nexport interface Position {\n    x: number,\n    y: number,\n    direction: DIRECTION,\n}\n\nexport class GameObject {\n    static createEmptyBoard() {\n        return range(0, BOARD_SIZE).map(() => {\n            return range(0, BOARD_SIZE).map(() => {\n                return {\n                    background: GameBackgrounds.DIRT,\n                };\n            });\n        })\n    }\n\n    static getBackgroundClass(background: GameBackgrounds) {\n        return {\n            [GameBackgrounds.FLAG]: Flag,\n            [GameBackgrounds.DIRT]: Dirt,\n            [GameBackgrounds.WATER]: Water, \n            [GameBackgrounds.MOVABLE_BLOCK_WATER]: MovableBlockWater,\n            [GameBackgrounds.ICE]: Ice,\n            [GameBackgrounds.THIN_ICE]: ThinIce,\n            [GameBackgrounds.TANK_MOVER_N]: TankMoverN,\n            [GameBackgrounds.TANK_MOVER_S]: TankMoverS,\n            [GameBackgrounds.TANK_MOVER_E]: TankMoverE,\n            [GameBackgrounds.TANK_MOVER_W]: TankMoverW,\n            [GameBackgrounds.TUNNEL]: Tunnel,\n        }[background];\n    }\n\n    static getObstacleClass(obstacle: GameObstacles) {\n        return {\n            [GameObstacles.BRICKS]: Bricks,\n            [GameObstacles.SOLID_BLOCK]: SolidBlock,\n            [GameObstacles.CRYSTAL_BLOCK]: CrystalBlock,\n            [GameObstacles.MOVABLE_BLOCK]: MovableBlock,\n            [GameObstacles.ANTI_TANK_N]: AntiTankN,\n            [GameObstacles.ANTI_TANK_S]: AntiTankS,\n            [GameObstacles.ANTI_TANK_W]: AntiTankW,\n            [GameObstacles.ANTI_TANK_E]: AntiTankE,\n            [GameObstacles.ANTI_TANK_DEAD_N]: AntiTankDeadN,\n            [GameObstacles.ANTI_TANK_DEAD_S]: AntiTankDeadS,\n            [GameObstacles.ANTI_TANK_DEAD_W]: AntiTankDeadW,\n            [GameObstacles.ANTI_TANK_DEAD_E]: AntiTankDeadE,\n            [GameObstacles.MIRROR_NW]: MirrorNW,\n            [GameObstacles.MIRROR_NE]: MirrorNE,\n            [GameObstacles.MIRROR_SE]: MirrorSE,\n            [GameObstacles.MIRROR_SW]: MirrorSW,\n            [GameObstacles.ROTARY_MIRROR_NW]: RotaryMirrorNW,\n            [GameObstacles.ROTARY_MIRROR_NE]: RotaryMirrorNE,\n            [GameObstacles.ROTARY_MIRROR_SE]: RotaryMirrorSE,\n            [GameObstacles.ROTARY_MIRROR_SW]: RotaryMirrorSW,\n        }[obstacle];\n    }\n\n    static getBackground(tile: Tile) {\n        return new (this.getBackgroundClass(tile.background))();\n    }\n\n    static getObstacle(tile: Tile) {\n        return !tile.object ? null : new (this.getObstacleClass(tile.object))();\n    }\n\n    static checkLaser(state: GameState) {\n        const { laser, tank, board } = state;\n        if (laser) {\n            const target = nextPosition(laser);\n            const tile = get(board, [target.y, target.x]);\n            if (tile) {\n                state.laser = target;\n                if (sameCoord(target, tank)) {\n                    state.status = 'FAIL';\n                } else {\n                    this.getObstacle(tile)?.handleLaser(state, target);\n                }\n            } else {\n                state.laser = null;\n            }\n            if (!state.laser) {\n                this.checkFire(state);\n            }\n        }\n    }\n\n    static checkPending(game: GameState) {\n        const { pending } = game;\n        if (game.status === 'FAIL') {\n            return;\n        }\n        game.pending = [];\n        each(\n            reverse(pending), \n            ({ from, to }) => {\n                this.handlePending(game, from , to)\n            }\n        );\n        game.pending = reverse(game.pending);\n    }\n\n    static handlePending(game: GameState, from: Position, to: Position) {\n        const { board } = game;\n        const toTile = get(board, [to.y, to.x]);\n        if (from) {\n            const fromTile = get(board, [from.y, from.x]);\n            this.getBackground(fromTile).handleLeaving(game, from);\n        }\n        this.getBackground(toTile).handleLanding(game, from, to);\n        return game.status !== 'FAIL';\n    }\n\n    static checkTank(game: GameState, prevBoard: Board) {\n        const { board, tank } = game;\n        const tile = board[tank.y][tank.x];\n        if (game.status !== 'FAIL') {\n            if (!tile.object) {\n                this.checkFire(game);\n            }\n            const background = this.getBackground(board[tank.y][tank.x]);\n            if (background.shouldCheckTank(game, prevBoard)) {\n                background.handleTank(game, false);\n            }\n        }\n    }\n\n    static checkFire(game: GameState) {\n        const { board, tank } = game;\n        const tile = board[tank.y][tank.x];\n        if (!tile.object && game.status !== 'FAIL') {\n            each([CMD.RIGHT, CMD.LEFT, CMD.DOWN, CMD.UP], (direction: DIRECTION) => {\n                forEachTile(board, { ...tank, direction }, (tile, current) => {\n                    return this.getObstacle(tile)?.sawTank(game, current);\n                });\n                return game.status !== 'FAIL';\n            });\n        }\n    }\n\n    static cleanUp(game: GameState) {\n        const { cleanUp, board } = game;\n        game.cleanUp = [];\n        each(cleanUp, (position) => {\n            this.getBackground(board[position.y][position.x]).cleanUp(game, position);\n        });\n    }\n\n    static moveTank(game: GameState, to: Position, handle: boolean = false, inSkipping: boolean = false) {\n        const { board, tank } = game;\n        const tile = board[to.y][to.x];\n        const background = GameObject.getBackground(tile);\n        game.prevTank = { ...tank };\n        if (isAvailable(to, game.board)) {\n            tank.x = to.x;\n            tank.y = to.y;\n            game.rendering = true;\n            if (tile.background === GameBackgrounds.TUNNEL) {\n                background.handleTankMove(game);\n            }\n            GameObject.checkFire(game);\n            if (game.status !== 'FAIL') {\n                if (handle) {\n                    background.handleTank(game, true);\n                } else if (!inSkipping) {\n                    background.skipTank(game);\n                }\n            } \n        }\n    }\n\n    static getObstacleCss(tile: Tile) {\n        return this.getObstacle(tile)?.css;\n    }\n\n    static getBackgroundCss(tile: Tile) {\n        return this.getBackground(tile)?.css;\n    }\n\n    css = '';\n\n    handleLeaving(game: GameState, position: Position) {};\n\n    pending(game: GameState, from: Position, to: Position, beforeCheckPending: boolean) {\n        game.pending.push({ from, to });\n    }\n}\n\nclass GameObstacle extends GameObject {\n    handleLaser(game: GameState, position: Position) {\n        game.laser = null;\n    }\n\n    sawTank(game: GameState, position: Position): boolean {\n        // false means current obstacle already blocked further obstacles seeing tank\n        return false;\n    }\n\n    skipLaser(game: GameState) {}\n\n    handleMove(game: GameState, from: Position, to: Position | null, beforeCheckPending: boolean) {\n        const { board, pending } = game;\n        const fromTile = board[from.y][from.x];\n        if (!to) {\n            to = nextPosition(from);\n        }\n        const index = pending.findIndex((p) => {\n            return sameCoord(p.to, from);\n        });\n        if (index > -1) {\n            pending.splice(index, 1);\n        }\n        if (fromTile.object && isAvailable(to, board)) {\n            const targetTile = get(board, [to.y, to.x]);\n            targetTile.object = fromTile.object;\n            delete fromTile.object;\n\n            // if (game.laser && sameCoord(from, game.laser)) {\n            //     GameObject.getObstacle(targetTile)?.skipLaser(game);\n            // }\n\n            if (targetTile.background === GameBackgrounds.TUNNEL) {\n                GameObject.handlePending(game, from, to);\n            } else {\n                GameObject.getBackground(targetTile).pending(game, from, to, beforeCheckPending);\n            }\n        }\n    }\n}\n\nclass Bricks extends GameObstacle {\n    css = 'BRICKS';\n\n    handleLaser(game: GameState, position: Position) {\n        super.handleLaser(game, position);\n        delete game.board[position.y][position.x].object;\n    };\n}\n\nclass SolidBlock extends GameObstacle {\n    css = 'SOLID_BLOCK';\n}\n\nclass MovableBlock extends GameObstacle {\n    css = 'MOVABLE_BLOCK';\n\n    handleLaser(game: GameState, position: Position) {\n        super.handleLaser(game, position);\n        this.handleMove(game, position, null, true);\n    }\n}\n\nclass AntiTankN extends GameObstacle {\n    css = 'ANTI_TANK_N';\n    dead = GameObstacles.ANTI_TANK_DEAD_N;\n    dead_direction: DIRECTION = CMD.DOWN;\n\n    handleLaser(game: GameState, position: Position) {\n        super.handleLaser(game, position);\n        if (position.direction === this.dead_direction) {\n            game.board[position.y][position.x].object = this.dead;\n        } else {\n            this.handleMove(game, position, null, true);\n        }\n    }\n\n    sawTank(game: GameState, position: Position): boolean {\n        const { tank } = game;\n        const direction = reverseDirection(this.dead_direction);\n        if (getDirection(position, tank) === direction) {\n            fireLasert(game, nextPosition({ ...position, direction, }));\n        }\n        return super.sawTank(game, position);\n    }\n}\n\nclass AntiTankS extends AntiTankN {\n    css = 'ANTI_TANK_S';\n    dead = GameObstacles.ANTI_TANK_DEAD_S;\n    dead_direction: DIRECTION = CMD.UP;\n}\n\nclass AntiTankE extends AntiTankN {\n    css = 'ANTI_TANK_E';\n    dead = GameObstacles.ANTI_TANK_DEAD_E;\n    dead_direction: DIRECTION = CMD.LEFT;\n}\n\nclass AntiTankW extends AntiTankN {\n    css = 'ANTI_TANK_W';\n    dead = GameObstacles.ANTI_TANK_DEAD_W;\n    dead_direction: DIRECTION = CMD.RIGHT;\n}\n\nclass AntiTankDeadN extends GameObstacle {\n    css = 'ANTI_TANK_DEAD_N';\n\n    handleLaser(game: GameState, position: Position) {\n        super.handleLaser(game, position);\n        this.handleMove(game, position, position, true);\n    }\n}\n\nclass AntiTankDeadS extends AntiTankDeadN {\n    css = 'ANTI_TANK_DEAD_S';\n}\n\nclass AntiTankDeadW extends AntiTankDeadN {\n    css = 'ANTI_TANK_DEAD_W';\n}\n\nclass AntiTankDeadE extends AntiTankDeadN {\n    css = 'ANTI_TANK_DEAD_E';\n}\n\nclass MirrorNW extends GameObstacle {\n    css = 'MIRROR_NW';\n    directions: DIRECTION[] = [CMD.UP, CMD.LEFT];\n    handleLaser(game: GameState, position: Position) {\n        super.handleLaser(game, position);\n        const index = this.directions.indexOf(position.direction);\n        if (index !== -1) {\n            this.hitBack(game, position);\n        } else {\n            this.hitMirror(game, position);\n        }\n    }\n\n    getFireDirections(): DIRECTION[] {\n        return [\n            reverseDirection(this.directions[0]),\n            reverseDirection(this.directions[1]),\n        ]\n    }\n\n    hitBack(game: GameState, position: Position) {\n        this.handleMove(game, position, null, true);\n    }\n\n    hitMirror(game: GameState, position: Position) {\n        const isMoving = game.pending.find(({ from, to }) => {\n            return sameCoord(to, position);\n        });\n        const fire_directions = this.getFireDirections()\n        const direction =  this.directions[1 - fire_directions.indexOf(position.direction)];\n        fireLasert(game, {\n            ...position,\n            direction\n        }, true);\n        if (isMoving && \n            [GameBackgrounds.ICE, GameBackgrounds.THIN_ICE].includes(\n                game.board[position.y][position.x].background\n            )\n        ) {\n            GameObject.checkLaser(game);\n        }\n    }\n\n    // skipLaser(game: GameState) {\n    //     // TODO: tmp hack, should move this logic to mirror and anti-tank\n    //     game.laser = {\n    //         ...to,\n    //         direction: game.laser.direction\n    //     };\n    // }\n}\n\nclass MirrorNE extends MirrorNW {\n    css = 'MIRROR_NE';\n    directions: DIRECTION[] = [CMD.UP, CMD.RIGHT];\n}\n\nclass MirrorSE extends MirrorNW {\n    css = 'MIRROR_SE';\n    directions: DIRECTION[] = [CMD.DOWN, CMD.RIGHT];\n}\n\nclass MirrorSW extends MirrorNW {\n    css = 'MIRROR_SW';\n    directions: DIRECTION[] = [CMD.DOWN, CMD.LEFT];\n}\n\nclass RotaryMirrorNW extends MirrorNW {\n    css = 'ROTARY_MIRROR_NW';\n    directions: DIRECTION[] = [CMD.UP, CMD.LEFT];\n    next_direction = GameObstacles.ROTARY_MIRROR_NE;\n\n    hitBack(game: GameState, position: Position) {\n        \n        game.board[position.y][position.x].object = this.next_direction;\n    }\n}\n\nclass RotaryMirrorNE extends RotaryMirrorNW {\n    css = 'ROTARY_MIRROR_NE';\n    directions: DIRECTION[] = [CMD.UP, CMD.RIGHT];\n    next_direction = GameObstacles.ROTARY_MIRROR_SE;\n}\n\nclass RotaryMirrorSE extends RotaryMirrorNW {\n    css = 'ROTARY_MIRROR_SE';\n    directions: DIRECTION[] = [CMD.DOWN, CMD.RIGHT];\n    next_direction = GameObstacles.ROTARY_MIRROR_SW;\n}\n\nclass RotaryMirrorSW extends RotaryMirrorNW {\n    css = 'ROTARY_MIRROR_SW';\n    directions: DIRECTION[] = [CMD.DOWN, CMD.LEFT];\n    next_direction = GameObstacles.ROTARY_MIRROR_NW;\n}\n\nclass CrystalBlock extends GameObstacle {\n    css = 'CRYSTAL_BLOCK';\n    handleLaser(game: GameState, position: Position) { }\n}\n\nclass GameBackground extends GameObject {\n    handleLanding(game: GameState, from: Position, to: Position) {}\n    handleTank(game: GameState, inSkipping: boolean) {}\n    handleTankMove(game: GameState) {}\n    skipTank(game: GameState) {}\n    cleanUp(game: GameState, position: Position) {}\n    shouldSkip(game: GameState, position: Position): boolean {\n        return false;\n    }\n    shouldCheckTank(game: GameState, prevBoard: Board) {\n        return true;\n    }\n}\n\nclass Dirt extends GameBackground {\n    css = 'DIRT';\n}\n\nclass MovableBlockWater extends GameBackground {\n    css = 'MOVABLE_BLOCK_WATER';\n}\n\nconst sameKindTunnel = (t1: Tile, t2: Tile) => {\n    return t1.background === GameBackgrounds.TUNNEL && t2.background === GameBackgrounds.TUNNEL && t1.color === t2.color;\n}\n\nclass Tunnel extends GameBackground {\n    css = 'TUNNEL';\n\n    handleLanding(game: GameState, from: Position, to: Position) {\n        super.handleLanding(game, from, to);\n        const { board } = game;\n        const tunnel = board[to.y][to.x];\n        let pendingTunnel = true;\n        each(board, (row, y) => {\n            each(row, (tile, x) => {\n                if (\n                    sameKindTunnel(tile, tunnel) && \n                    !sameCoord(to, {x, y, direction: CMD.UP}) &&\n                    !tile.object\n                ) {\n                    tile.object = tunnel.object;\n                    delete tunnel.object;\n                    pendingTunnel = false;\n                    return pendingTunnel;\n                }\n            });\n            return pendingTunnel;\n        });\n        if (pendingTunnel) {\n            game.pendingTunnels.push({\n                ...to,\n                direction: CMD.UP // TODO: use UP to indicate pending obstacle for now, should refactoring this\n            });\n        }\n    }\n\n    handleTankMove(game: GameState) {\n        super.handleTankMove(game);\n        const { board, tank } = game;\n        const tunnel = board[tank.y][tank.x];\n        let pendingTunnel = true;\n        each(board, (row, y) => {\n            each(row, (tile, x) => {\n                if (\n                    sameKindTunnel(tile, tunnel) && \n                    !sameCoord(tank, {x, y, direction: CMD.UP}) &&\n                    !tile.object\n                ) {\n                    tank.x = x;\n                    tank.y = y;\n                    pendingTunnel = false;\n                    return pendingTunnel;\n                }\n            });\n            return pendingTunnel;\n        });\n        if (pendingTunnel) {\n            game.pendingTunnels.push({ \n                ...tank,\n                direction: CMD.DOWN // TODO: use DOWN to indicate pending tank for now, should refactoring this\n            });\n        }\n    }\n\n    handleLeaving(game: GameState, position: Position) { \n        super.handleLeaving(game, position);\n        const { board, tank, pendingTunnels } = game;\n        const obstacleIndex = findIndex(pendingTunnels, ({ x, y, direction }) => {\n            return sameKindTunnel(board[y][x], board[position.y][position.x]) && direction === CMD.UP;\n        });\n        const tankIndex = findIndex(pendingTunnels, ({ x, y, direction }) => {\n            return sameKindTunnel(board[y][x], board[position.y][position.x]) && direction === CMD.DOWN;\n        });\n        if (obstacleIndex > -1) {\n            const pending = pendingTunnels.splice(obstacleIndex, 1)[0];\n            if (!sameCoord(pending, position)) {\n                const pedningTile = board[pending.y][pending.x];\n                if (pedningTile.object) {\n                    const targetTile = get(board, [position.y, position.x]);\n                    targetTile.object = pedningTile.object;\n                    delete pedningTile.object;\n                }\n            }\n        } else if (tankIndex > -1) {\n            const pending = pendingTunnels.splice(tankIndex, 1)[0];\n            if (!sameCoord(pending, position) && sameCoord(tank, pending)) {\n                if (isAvailable(position, game.board)) {\n                    tank.x = position.x;\n                    tank.y = position.y;\n                    game.rendering = true;\n                }\n            }\n        }\n    }\n}\n\nclass Flag extends GameBackground {\n    css = 'FLAG';\n\n    handleTank(game: GameState, inSkipping: boolean) {\n        super.handleTank(game, inSkipping);\n        game.status = \"WIN\";\n    }\n\n    skipTank(game: GameState) {\n        game.status = \"WIN\";\n    }\n}\n\nclass Water extends GameBackground {\n    css = 'WATER';\n\n    handleLanding(game: GameState, from: Position, to: Position) {\n        super.handleLanding(game, from, to);\n        const { board } = game;\n        const tile = board[to.y][to.x];\n        if (tile.object === GameObstacles.MOVABLE_BLOCK) {\n            tile.background = GameBackgrounds.MOVABLE_BLOCK_WATER;\n        }\n        delete tile.object;\n    };\n\n    handleTank(game: GameState, inSkipping: boolean) {\n        super.handleTank(game, inSkipping);\n        game.status = 'FAIL';\n    }\n\n    pending(game: GameState, from: Position, to: Position, beforeCheckPending: boolean) {\n        super.pending(game, from, to, beforeCheckPending);\n        this.handleLanding(game, from, to);\n    }\n\n    skipTank(game: GameState) {\n        const { board, prevTank } = game;\n        const prevTile = board[prevTank.y][prevTank.x];\n        if (prevTile.background === GameBackgrounds.ICE) {\n            this.handleTank(game, true);\n        }\n    }\n}\n\nclass Ice extends GameBackground {\n    css = 'ICE';\n\n    handleLanding(game: GameState, from: Position, to: Position) {\n        super.handleLanding(game, from, to);\n        const target = this.getNextTarget(game, from, to, true);\n        if (target) {\n            GameObject.getObstacle(game.board[to.y][to.x])?.handleMove(game, to, target, false);\n        }\n    }\n\n    handleTank(game: GameState, inSkipping: boolean) {\n        super.handleTank(game, inSkipping);\n        const { tank, prevTank } = game;\n        const direction = getDirection(prevTank, tank);\n        if (direction) {\n            GameObject.moveTank(game, nextPosition({\n                ...tank,\n                direction,\n            }), false, false);\n        }\n    }\n\n    pending(game: GameState, from: Position, to: Position, beforeCheckPending: boolean) {\n        if (!beforeCheckPending || this.shouldPending(game, from, to)) {\n            super.pending(game, from, to, beforeCheckPending);\n        }\n    }\n\n    shouldPending(game: GameState, from: Position, to: Position): boolean {\n        return !!this.getNextTarget(game, from, to, false);\n    }\n\n    getNextTarget(game: GameState, from: Position, to: Position, checkTank: boolean): Position | null {\n        const direction = getDirection(from, to);\n        if (direction) {\n            const target = nextPosition({ ...to, direction, });\n            if ((!checkTank || !sameCoord(game.tank, target)) && isAvailable(target, game.board)) {\n                return target;\n            }\n        }\n        return null;\n    }\n\n    shouldSkip(game: GameState, position: Position): boolean {\n        const tile = get(game.board, [position.y, position.x])\n        const background = GameObject.getBackground(tile);\n        return !Boolean(tile.object) && !(background instanceof Ice);\n    }\n\n    shouldCheckTank(game: GameState, prevBoard: Board) {\n        const { tank } = game;\n        return !prevBoard[tank.y][tank.x].object;\n    }\n}\n\nclass ThinIce extends Ice {\n    css = 'THIN_ICE';\n\n    handleLanding(game: GameState, from: Position, to: Position) {\n        super.handleLanding(game, from, to);\n        const tile = game.board[to.y][to.x];\n        if (tile.object) {\n            // TODO: this doesn't make much sense, should handle this in cleanUp. this is for tutor.lvl 68\n            new Water().handleLanding(game, to, to);\n        }\n        game.cleanUp.push(to);\n    }\n\n    cleanUp(game: GameState, position: Position) {\n        game.board[position.y][position.x].background = GameBackgrounds.WATER\n    }\n\n    shouldPending(game: GameState, from: Position, to: Position) {\n        return true;\n    }\n\n    handleTank(game: GameState, inSkipping: boolean) {\n        const { tank, board } = game;\n        const position = { ...tank };\n        const tile = board[position.y][position.x];\n        super.handleTank(game, inSkipping);\n        tile.background = GameBackgrounds.WATER;\n        if (sameCoord(position, game.tank)) {\n            GameObject.getBackground(tile).handleTank(game, inSkipping);\n        }\n    }\n}\n\nclass TankMoverN extends GameBackground {\n    css = 'TANK_MOVER_N';\n    direction: DIRECTION = CMD.UP;\n\n    handleTank(game: GameState, inSkipping: boolean) {\n        super.handleTank(game, inSkipping);\n        GameObject.moveTank(game, nextPosition({ ...game.tank, direction: this.direction }), false, true);\n    }\n\n    skipTank(game: GameState) {\n        GameObject.moveTank(game, nextPosition({ ...game.tank, direction: this.direction }), false, true);\n    }\n\n    shouldSkip(game: GameState, position: Position): boolean {\n        const tile = get(game.board, [position.y, position.x]);\n        const background = GameObject.getBackground(tile);\n        return !Boolean(tile.object) && !(background instanceof TankMoverN);\n    }\n\n    shouldCheckTank(game: GameState, prevBoard: Board) {\n        const { board, tank } = game;\n        return !board[tank.y][tank.x].object;\n    }\n}\n\nclass TankMoverS extends TankMoverN {\n    css = 'TANK_MOVER_S';\n    direction: DIRECTION = CMD.DOWN;\n}\n\nclass TankMoverW extends TankMoverN {\n    css = 'TANK_MOVER_W';\n    direction: DIRECTION = CMD.LEFT;\n}\n\nclass TankMoverE extends TankMoverN {\n    css = 'TANK_MOVER_E';\n    direction: DIRECTION = CMD.RIGHT;\n}\n","import { get, map, max, min } from 'lodash';\nimport { createSlice, PayloadAction  } from '@reduxjs/toolkit';\nimport { AppThunk } from '../../app/store';\n\nimport { nextPosition, isAvailable, Board, Position, GameObject, } from './tiles';\nimport { parseBoard } from './files';\n\nexport const BOARD_SIZE = 16;\n\nexport interface TLEVEL {\n    board: number[][],\n    levelName: string,\n    hint: string,\n    author: string,\n    scoreDifficulty: number,\n}\n\nexport enum CMD {\n    UP = 'N',\n    DOWN = 'S',\n    LEFT = 'W',\n    RIGHT = 'E',\n    FIRE_UP = '0',\n    FIRE_DOWN = '1',\n    FIRE_LEFT = '2',\n    FIRE_RIGHT = '3',\n    FIRE = ' ',\n    UNDO = 'UNDO',\n    PAUSE = 'PAUSE',\n    NEXT_LEVEL = 'NEXT_LEVEL',\n    PREV_LEVEL = 'PREV_LEVEL',\n    PREV_FRAME = 'PREV_FRAME',\n    NEXT_FRAME = 'NEXT_FRAME',\n    HINT = 'HINT',\n    RESTART = 'RESTART',\n    SAVE_POSITION = 'SAVE_POSITION',\n    RESTORE_POSITION = 'RESTORE_POSITION',\n};\n\nexport type DIRECTION = CMD.UP|CMD.DOWN|CMD.LEFT|CMD.RIGHT;\nexport const isDirection = (cmd: CMD): cmd is DIRECTION => {\n    return [CMD.UP, CMD.DOWN, CMD.LEFT, CMD.RIGHT].includes(cmd);\n}\nexport type FIRE_DIRECTION = CMD.FIRE_UP|CMD.FIRE_DOWN|CMD.FIRE_LEFT|CMD.FIRE_RIGHT;\n\ntype BoardCMD = DIRECTION|CMD.FIRE;\nconst isBoardCMD = (cmd: CMD): cmd is BoardCMD => {\n    return isDirection(cmd) || cmd === CMD.FIRE;\n}\nexport type RecordCMD = DIRECTION|FIRE_DIRECTION;\n\nexport interface PlayField {\n    board: Board,\n    tank: Position,\n    prevTank: Position,\n    laser: Position | null,\n    pending: {from: Position, to: Position}[], // may not need this\n    pendingTunnels: Position[],\n    status: Status,\n    levelIndex: number,\n}\n\nexport interface GameState extends PlayField {\n    cleanUp: Position[],\n    timer: number,\n    rendering: boolean,\n    pause: boolean,\n    positionSaved: boolean,\n    frameIndex: number,\n    levels: TLEVEL[],\n};\n\nexport type Status = \"WIN\" | \"FAIL\" | \"PLAYING\"\n\nclass DB {\n    record: RecordCMD[] = [];\n    history: PlayField[] = [];\n    frames: PlayField[] = [];\n    snapshoot: { state: PlayField, record: RecordCMD[] } | null = null;\n\n    save(state: GameState, cmd: BoardCMD) {\n        const { \n            board, tank, prevTank, laser, pending, pendingTunnels, status, levelIndex\n        } = state;\n        if (cmd === CMD.FIRE) {\n            const fireMap: {[key in DIRECTION]: RecordCMD} = {\n                [CMD.UP]: CMD.FIRE_UP,\n                [CMD.DOWN]: CMD.FIRE_DOWN,\n                [CMD.LEFT]: CMD.FIRE_LEFT,\n                [CMD.RIGHT]: CMD.FIRE_RIGHT,\n            };\n            this.record.push(fireMap[tank.direction]);\n        } else {\n            this.record.push(cmd);\n        }\n        this.history.push({ \n            board, tank, prevTank, laser, pending, pendingTunnels, status, levelIndex\n        });\n    }\n\n    saveFrame(state: GameState) {\n        const { \n            board, tank, prevTank, laser, pending, pendingTunnels, status, levelIndex\n        } = state;\n        this.frames.push({\n            board, tank, prevTank, laser, pending, pendingTunnels, status, levelIndex\n        });\n    }\n\n    savePosition(state: GameState) {\n        const { \n            board, tank, prevTank, laser, pending, pendingTunnels, status, levelIndex\n        } = state;\n        this.snapshoot = { \n            state: {board, tank, prevTank, laser, pending, pendingTunnels, status, levelIndex},\n            record: this.record,\n        };\n    }\n}\n\nexport const db = new DB();\n\nexport const initialState: GameState = {\n    board: GameObject.createEmptyBoard(),\n    tank: {x: 0, y: 0, direction: CMD.UP}, \n    prevTank: {x: 0, y: 0, direction: CMD.UP}, \n    laser: null,\n    pending: [],\n    pendingTunnels: [],\n    status: \"PLAYING\",\n    cleanUp: [],\n    levelIndex: 0,\n    timer: 0,\n    rendering: false,\n    pause: false,\n    positionSaved: false,\n    frameIndex: 0,\n    levels: [],\n};\n\nconst gameSlice = createSlice({\n    name: 'game',\n    initialState,\n    reducers: {\n        loadLevels(state, action: PayloadAction<{ levels: TLEVEL[], levelIndex: number }>) {\n            const { levels, levelIndex } = action.payload;\n            state.levels = levels;\n            localStorage.setItem('levels', JSON.stringify(levels));\n            gameSlice.caseReducers.loadLevel(state, loadLevel(levelIndex));\n        },\n        loadLevel(state, action: PayloadAction<number>) {\n            const { levels } = state;\n            const levelIndex = action.payload;\n            const level = get(levels, [levelIndex]);\n            console.log(`${levelIndex}: ${db.record.join('')}`);\n            if (!level) {\n                return;\n            }\n            localStorage.setItem('levelIndex', JSON.stringify(levelIndex));\n            const { board, tank } = parseBoard(level);\n            state.board = board;\n            state.tank = tank;\n            state.prevTank = {...tank};\n            state.laser = null;\n            state.pending = [];\n            state.pendingTunnels = [];\n            state.timer = state.timer === 0 ? 1 : 0;\n            state.rendering = false;\n            state.pause = false;\n            state.status = 'PLAYING';\n            state.frameIndex = 0;\n            db.record = [];\n            db.frames = [];\n            if (state.levelIndex !== levelIndex) {\n                db.history = [];\n                db.snapshoot = null;\n                state.levelIndex = levelIndex;\n                state.positionSaved = false;\n            }\n        },\n        undo(state) {\n            db.record.pop();\n            db.frames = [];\n            return {\n                ...state,\n                ...(db.history.pop()),\n                timer: state.timer + 1,\n                frameIndex: 0,\n            };\n        },\n        savePosition(state) {\n            state.positionSaved = true;\n        },\n        restorePosition(state) {\n            db.record = [...db.snapshoot?.record || []];\n            db.frames = [];\n            return {\n                ...state,\n                ...(db.snapshoot?.state || {}),\n                timer: state.timer + 1,\n                frameIndex: 0,\n            };\n        },\n        setFrame(state, action: PayloadAction<number>) {\n            const frameIndex = action.payload;\n            return {\n                ...state,\n                ...(db.frames[db.frames.length - 1 - frameIndex]),\n                frameIndex,\n                timer: state.timer + 1,\n            }\n        },\n        moveTank(state, action: PayloadAction<DIRECTION>) {\n            const { tank } = state;\n            const cmd = action.payload;\n            db.frames = [];\n            if (tank.direction === cmd) {\n                GameObject.moveTank(state, nextPosition(tank), true);\n            } else {\n                tank.direction = cmd;\n                state.prevTank = { ...tank };\n            }\n            state.timer += 1;\n            state.rendering = state.status !== 'FAIL';\n        },\n        fireTank(state) {\n            const { tank } = state;\n            db.frames = [];\n            if (!state.laser) {\n                state.laser = tank;\n                state.rendering = true;\n                state.timer += 1;\n            }\n            // gameSlice.caseReducers.renderFrame(state);\n        },\n        renderFrame(state) {\n            const { board } = state;\n            const prevBoard: Board = map(board, (row) => {\n                return map(row, (tile) => {\n                    return {...tile};\n                });\n            });\n            state.rendering = false;\n            // move laser\n            // check fail \n            // obstacle handle laser \n            //      move obstacle, pending target and src\n            GameObject.checkLaser(state);\n            // handle landing obstacle \n            // handle leaving obstacle\n            GameObject.checkPending(state);\n            // obstacle sawTank\n            // background handleTank\n            GameObject.checkTank(state, prevBoard);\n            GameObject.cleanUp(state);\n            state.timer += 1;\n            state.rendering = state.status === 'PLAYING' && (\n                state.rendering || Boolean(state.laser) || state.pending.length > 0\n            )\n        },\n    },\n});\n\nexport const {\n    loadLevel, loadLevels, savePosition, restorePosition, moveTank, fireTank,\n} = gameSlice.actions;\n\nexport const renderFrame = (): AppThunk => (dispatch, getState) => {\n    dispatch(gameSlice.actions.renderFrame());\n    db.saveFrame(getState().game);\n}\n\nexport const exec = (cmd: CMD): AppThunk => (dispatch, getState) => {\n    const actions = gameSlice.actions;\n    const { game } = getState();\n    const { tank, board, status, pending, laser, levelIndex, frameIndex } = game;\n    if (cmd === CMD.PREV_FRAME) {\n        dispatch(actions.setFrame(\n            min([frameIndex + 1, db.frames.length - 1]) || \n            (db.frames.length - 1)\n        ));\n    } else if (cmd === CMD.NEXT_FRAME) {\n        dispatch(actions.setFrame(max([frameIndex - 1, 0]) || 0));\n    } else if (cmd === CMD.UNDO) {\n        dispatch(actions.undo());\n    } else if (cmd === CMD.RESTART) {\n        dispatch(loadLevel(levelIndex));\n    } else if (cmd === CMD.SAVE_POSITION && frameIndex === 0) {\n        db.savePosition(game);\n        dispatch(savePosition());\n    } else if (cmd === CMD.RESTORE_POSITION) {\n        dispatch(restorePosition());\n    } else if (cmd === CMD.NEXT_LEVEL) {\n        dispatch(loadLevel(levelIndex + 1));\n    } else if (cmd === CMD.PREV_LEVEL) {\n        dispatch(loadLevel(levelIndex - 1));\n    } else if (isBoardCMD(cmd)) {\n        if (frameIndex > 0) {\n            dispatch(actions.setFrame(0));\n        } else if (pending.length === 0 && !laser && status === 'PLAYING') {\n            const target = nextPosition(tank);\n            if (cmd === CMD.FIRE) {\n                db.save(game, cmd);\n                dispatch(fireTank());\n                db.saveFrame(game);\n            } else if (\n                isDirection(cmd) && \n                (tank.direction !== cmd || isAvailable(target, board))\n            ) {\n                db.save(game, cmd);\n                dispatch(moveTank(cmd));\n                db.saveFrame(game);\n            }\n        }\n    }\n};\n\nexport default gameSlice;\n","import { GameBackgrounds, GameObstacles } from './tiles';\n\nexport const saveDataMap: {[key: number]: any} = {\n    0: {\n        background: GameBackgrounds.DIRT,\n    },\n    2: {\n        background: GameBackgrounds.FLAG,\n    },\n    3: {\n        background: GameBackgrounds.WATER,\n    },\n    4: {\n        object: GameObstacles.SOLID_BLOCK,\n    },\n    5: {\n        object: GameObstacles.MOVABLE_BLOCK, ///////\n    },\n    6: {\n        object: GameObstacles.BRICKS,\n    },\n    7: {\n        object: GameObstacles.ANTI_TANK_N\n    },\n    8: {\n        object: GameObstacles.ANTI_TANK_E\n    },\n    9: {\n        object: GameObstacles.ANTI_TANK_S\n    },\n    10: {\n        object: GameObstacles.ANTI_TANK_W\n    },\n    11: {\n        object: GameObstacles.MIRROR_NW\n    },\n    12: {\n        object: GameObstacles.MIRROR_NE\n    },\n    13: {\n        object: GameObstacles.MIRROR_SE\n    },\n    14: {\n        object: GameObstacles.MIRROR_SW\n    },\n    15: {\n        background: GameBackgrounds.TANK_MOVER_N\n    },\n    16: {\n        background: GameBackgrounds.TANK_MOVER_E\n    },\n    17: {\n        background: GameBackgrounds.TANK_MOVER_S\n    },\n    18: {\n        background: GameBackgrounds.TANK_MOVER_W\n    },\n    19: {\n        object: GameObstacles.CRYSTAL_BLOCK\n    },\n    20: {\n        object: GameObstacles.ROTARY_MIRROR_NW\n    },\n    21: {\n        object: GameObstacles.ROTARY_MIRROR_NE\n    },\n    22: {\n        object: GameObstacles.ROTARY_MIRROR_SE\n    },\n    23: {\n        object: GameObstacles.ROTARY_MIRROR_SW\n    },\n    24: {\n        background: GameBackgrounds.ICE\n    },\n    25: {\n        background: GameBackgrounds.THIN_ICE,\n    },\n}\n","import { map, sum, range, chunk, trim } from 'lodash';\n\nimport { CMD } from './game';\nimport { Board, Position, GameBackgrounds, GameObject } from './tiles';\nimport { saveDataMap } from './consts';\n\nexport interface TLEVEL {\n    board: number[][],\n    levelName: string,\n    hint: string,\n    author: string,\n    scoreDifficulty: number,\n}\n\nexport const parseBoard = (tLevel: TLEVEL): { board: Board, tank: Position } => {\n    const colors = [\n        'FB2D0F', '36FA0E', '1538FF', '36FCFF', 'FFFB0A', 'F542F9', 'FFFFFF', 'A1A1A1'\n    ];\n    const board: Board = GameObject.createEmptyBoard();\n    const tank: Position = {x: 0, y: 0, direction: CMD.UP};\n\n    tLevel.board.forEach((row, i) => {\n        return row.forEach((cell, j) => {\n            if (cell === 1) {\n                tank.x = i;\n                tank.y = j;\n                tank.direction = CMD.UP;\n                board[j][i] = {\n                    background: GameBackgrounds.DIRT,\n                }\n            } else if (cell > 63 && cell < 96) {\n                board[j][i] = {\n                    color: colors[(cell & 15) >> 1],\n                    background: GameBackgrounds.TUNNEL,\n                };\n            } else {\n                const result = saveDataMap[cell];\n                if (!result) {\n                    console.log(cell);\n                }\n                board[j][i] = {\n                    background: GameBackgrounds.DIRT,\n                    ...result,\n                };\n            }\n        });\n    });\n    return { board, tank };\n}\n\n\nconst toString = (buffer: ArrayBuffer) => {\n    return String.fromCharCode.apply(\n        null, Array.from(new Uint8Array(buffer)).filter(Boolean)\n    );\n}\n\nexport const openDataFile = (buffer: ArrayBuffer): TLEVEL[] => {\n    const tLevel = {\n        board: 16 * 16,\n        levelName: 31,\n        hint: 256,\n        author: 31,\n        scoreDifficulty: 2,\n    }; // 576\n    const sizeOfTLevel = sum(Object.values(tLevel));\n\n    const levels = map(range(Math.floor(buffer.byteLength / sizeOfTLevel)), (i): TLEVEL => {\n        let cursor = sizeOfTLevel * i;\n        const data: any = {};\n        map(tLevel, (size, key) => {\n            data[key] = buffer.slice(cursor, cursor + size);\n            cursor += size;\n        });\n\n        \n        return {\n            board: chunk(Array.from(new Uint8Array(data.board)), 16),\n            levelName: toString(data.levelName),\n            hint: toString(data.hint),\n            author: toString(data.author),\n            scoreDifficulty: new Uint16Array(data.scoreDifficulty)[0],\n        }\n    });\n    return levels;\n};","import { map, min, range, bindAll, debounce } from 'lodash';\nimport React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\n\nimport { RootState } from '../../app/rootReducer';\nimport { BOARD_SIZE, CMD, exec, renderFrame, GameState, loadLevel, DIRECTION } from './game';\nimport { Tile, GameBackgrounds, GameObject } from './tiles';\n\nimport './Board.css';\n\ninterface BoardProps {\n    game: GameState,\n}\n\ninterface BoardState {\n    limit: number,\n}\n\nconst BoardTile = React.memo(({ tile, tileSize }: { tile: Tile, tileSize: number }) => {\n    return <div style={{ width: tileSize, height: tileSize }} className={[\n        'board-object',\n        GameObject.getBackgroundCss(tile),\n    ].filter(Boolean).join(' ')}>\n        {tile.background === GameBackgrounds.TUNNEL && <div style={{ \n            background: 'transparent',\n            borderRadius: '50%',\n            border: `${tileSize/8}px solid #${tile.color}`,\n            boxSizing: 'border-box',\n        }}/>}\n        {tile.object && <div className={GameObject.getObstacleCss(tile)}/>} \n    </div>\n});\n\nconst BoardRow = React.memo(({ row, tileSize }: {row: Tile[], tileSize: number}) => {\n    return <div className=\"row\">\n        {map(row, (tile, j) => {\n            return <BoardTile key={j} tile={tile} tileSize={tileSize}/>\n        })}\n    </div>\n});\n\nconst directionToStr = (direction: DIRECTION) => {\n    const directionMap: {[key in DIRECTION]: string} = {\n        [CMD.UP]: 'N',\n        [CMD.DOWN]: 'S',\n        [CMD.LEFT]: 'W',\n        [CMD.RIGHT]: 'E',\n    };\n    return directionMap[direction];\n}\n\nclass Board extends React.Component<BoardProps, BoardState> {\n    state = { limit: 0 };\n    boardRef = React.createRef<HTMLInputElement>();\n    interval!: NodeJS.Timeout;\n\n    constructor(props: BoardProps) {\n        super(props)\n        bindAll(this, ['handleResize']);\n    }\n\n    componentDidMount() {\n        window.addEventListener('resize', this.handleResize);\n        const animations = ['bg0', 'bg1', 'bg2'];\n        this.interval = setInterval(async () => {\n            const el = this.boardRef.current;\n            if (el) {\n                const backgrounds = el.querySelectorAll([\n                    '.ANTI_TANK_N', '.ANTI_TANK_E', '.ANTI_TANK_S', '.ANTI_TANK_W',\n                    '.TANK_MOVER_N', '.TANK_MOVER_S', '.TANK_MOVER_W', '.TANK_MOVER_E',\n                    '.FLAG', '.WATER',\n                ].join(', '));\n                const bg = animations.shift() || '';\n                backgrounds.forEach((background) => {\n                    background.classList.remove(...animations);\n                    background.classList.add(bg);\n                });\n                animations.push(bg);\n            }\n        }, 600);\n        this.handleResize();\n    }\n\n    componentWillUnmount() {\n        window.removeEventListener('resize', this.handleResize);\n        clearInterval(this.interval);\n    }\n\n    handleResize() {\n        if (this.boardRef.current) {\n            const { offsetWidth: width, offsetHeight: height } = this.boardRef.current;\n            this.setState({ limit: min([width, height]) ?? 0 });\n        }\n    }\n\n    shouldComponentUpdate(nextProps: BoardProps, nextState: BoardState) {\n        return nextState.limit !== this.state.limit ||\n            nextProps.game.timer !== this.props.game.timer \n        ;\n    }\n\n    render() {\n        const { game } = this.props;\n        const { limit } = this.state;\n        const { board, tank, laser } = game;\n        const tileSize = Math.floor(limit / (BOARD_SIZE + 2));\n        const tileStyle = { width: tileSize, height: tileSize };\n        return <div ref={this.boardRef} className=\"Board\">\n            <div>\n                {map([\n                    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P'\n                ], (letter, i) => {\n                    return <div key={i} style={{ width: tileSize, display: 'inline-block' }}>{letter}</div>\n                })}\n            </div>\n            <div style={{\n                width: tileSize * BOARD_SIZE, height: tileSize * BOARD_SIZE, margin: '0 auto'\n            }}>\n                {map(board, (row, i) => {\n                    return <BoardRow key={i} row={row} tileSize={tileSize}/>\n                })}\n                {map(range(BOARD_SIZE), (i) => {\n                    return <div key={i} style={{\n                        position: 'absolute', verticalAlign: 'center', lineHeight: `${tileSize}px`,\n                        left: -tileSize, top: i * tileSize\n                    }}>{i + 1}</div>\n                })}\n                <div className={`tank TANK_${directionToStr(tank.direction)}`} style={{ \n                    left: tank.x * tileSize, top: tank.y * tileSize, ...tileStyle\n                }}/>\n                {laser && <div className={`laser ${directionToStr(laser.direction)}`} \n                    style={[CMD.UP, CMD.DOWN].includes(laser.direction) ? { \n                        left: laser.x * tileSize + (tileSize / 2 - 2), \n                        top: laser.y * tileSize, \n                        ...tileStyle, width: 4,\n                    } : {\n                        left: laser.x * tileSize, \n                        top: laser.y * tileSize + (tileSize / 2 - 1), \n                        ...tileStyle, height: 4,\n                    }}\n                />}\n            </div>\n            <div>\n                {map(range(0, 16), (i) => {\n                    return <div key={i} style={{ width: tileSize, display: 'inline-block' }}>{i + 1}</div>\n                })}\n            </div>\n        </div>\n    }\n}\n\nexport default () => {\n    const game = useSelector((state: RootState) => state.game)\n    const ui = useSelector((state: RootState) => state.ui)\n    const dispatch = useDispatch();\n    const { status, levelIndex } = game;\n    const debounceRenderFrame = debounce(() => {\n        return dispatch(renderFrame());\n    }, ui.renderInterval);\n\n    useEffect(() => {\n        const handleKeyDown = (e: KeyboardEvent) => {\n            const cmdMap: {[key: string]: CMD} = {\n                ARROWUP: CMD.UP,\n                ARROWDOWN: CMD.DOWN,\n                ARROWLEFT: CMD.LEFT,\n                ARROWRIGHT: CMD.RIGHT,\n                'U': CMD.UNDO,\n                ' ': CMD.FIRE,\n                'P': CMD.PAUSE,\n            };\n            const cmd = cmdMap[e.key.toUpperCase()];\n            if (cmd) {\n                dispatch(exec(cmd));\n            }\n        };\n        window.addEventListener('keydown', handleKeyDown);\n        return () => window.removeEventListener('keydown', handleKeyDown);\n    }, [dispatch]);\n\n    useEffect(() => {\n        if (game.rendering && !game.pause) {\n            debounceRenderFrame();\n        }\n    }, [debounceRenderFrame, game]);\n\n    useEffect(() => {\n        if (status === 'WIN') {\n            debounceRenderFrame.cancel();\n            dispatch(loadLevel(levelIndex + 1));\n        }\n    }, [dispatch, levelIndex, status, debounceRenderFrame])\n\n    return <Board game={game}/>\n}","import { map } from 'lodash';\nimport React, { useState } from 'react';\nimport { useDispatch } from 'react-redux';\n\nimport { loadLevels } from '../../features/game/game';\nimport { openDataFile } from '../../features/game/files';\n\nimport './MenuBar.css';\n\nexport default () => {\n    const dispatch = useDispatch();\n    const [currentMenu, setMenu] = useState<null|{ menu: any, top: number, left: number}>(null);\n\n    const handleFile = (file: File) => {\n        const reader = new FileReader();\n        reader.onload = (e) => {\n            if (e.target?.result) {\n                dispatch(loadLevels({\n                    levels: openDataFile(e.target?.result as ArrayBuffer),\n                    levelIndex: 0\n                }));\n            }\n        };\n        reader.readAsArrayBuffer(file);\n    }\n\n    return <div className=\"MenuBar\">\n        {map([\n            {\n                name: 'Game',\n                items: [\n                    {\n                        render: () => {\n                            return <div>\n                                <label>\n                                    Open Data File\n                                    <input id=\"fileInput\" type=\"file\" \n                                        style={{display: 'none'}} \n                                        onChange={(e) => {\n                                            const files = e.currentTarget.files;\n                                            if (files?.length) {\n                                                handleFile(files[0]);\n                                            }\n                                            setMenu(null);\n                                        }}\n                                    />\n                                </label>\n                            </div>\n                        },\n                    },\n                ],\n            },\n            {\n                name: 'Options',\n                items: [\n                    {name: 'Animation'},\n                    // {name: 'Sound'},\n                ],\n            },\n            {\n                name: 'Editor', \n                onClick: () => {\n                    setMenu(null);\n                },\n            },\n            {\n                name: 'Help',\n                items: [\n                    {name: 'About'},\n                ],\n            },\n        ], (menu, i) => {\n            const { name, ...props } = menu;\n            return <div key={i}\n                className={`MenuBarItem ${name === currentMenu?.menu.name ? 'active ' : ''}`} \n                onClick={(event) => {\n                    const { offsetTop, offsetHeight, offsetLeft } = event.currentTarget;\n                    setMenu(currentMenu ? null : {\n                        menu,\n                        top: offsetTop + offsetHeight,\n                        left: offsetLeft,\n                    });\n                }}\n                onMouseEnter={(event) => {\n                    const { offsetTop, offsetHeight, offsetLeft } = event.currentTarget;\n                    if (currentMenu) {\n                        setMenu({\n                            menu,\n                            top: offsetTop + offsetHeight,\n                            left: offsetLeft,\n                        });\n                    }\n                }}\n                {...props}\n            >{name}</div>\n        })}\n        {<ul className=\"Menu\" style={!currentMenu?.menu.items ? {display: 'none'} : {\n            top: currentMenu.top,\n            left: currentMenu.left,\n        }}>\n            {map(currentMenu?.menu.items, ({ name, render }, i) => {\n                return <li key={i}>\n                    {render ? render() : name}\n                </li>;\n            })}\n        </ul>}\n    </div>\n}","import { createSlice, PayloadAction  } from '@reduxjs/toolkit';\n\nexport interface UIState {\n    renderInterval: number,\n};\n\nconst initialState: UIState = {\n    renderInterval: 100,\n};\n\nconst uiSlice = createSlice({\n    name: 'game',\n    initialState,\n    reducers: {\n        setRenderInterval(state, action: PayloadAction<number>) {\n            const interval = action.payload;\n            const max_interval = 10 * 1000;\n            if (interval >= 0 && interval <= max_interval) {\n                state.renderInterval = interval;\n            }\n        }\n    },\n});\n\nexport default uiSlice;\n","import { get, map, debounce, toNumber } from 'lodash';\nimport React, { useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\n\nimport { RootState } from '../../app/rootReducer';\nimport { exec, db, CMD, isDirection, TLEVEL, loadLevel } from '../game/game';\nimport uiSlice from '../ui/ui';\n\nimport './ControlPanel.css';\n\nconst { setRenderInterval } = uiSlice.actions;\n\nconst LevelsPopup = ({ levels, onClick }: { levels: TLEVEL[], onClick: (i: number) => void }) => {\n    return <div className=\"LevelsPopup\">\n        <table>\n            <thead>\n                <tr>\n                    <th>Lev #</th>\n                    <th>Name</th>\n                    <th>Author</th>\n                </tr>\n            </thead>\n            <tbody>\n                {map(levels, (level, i) => {\n                    return <tr key={i} className={i % 2 === 0 ? 'odd' : 'even'} onClick={() => {\n                        onClick(i);\n                    }}>\n                        <td>{i + 1}</td>\n                        <td>{level.levelName}</td>\n                        <td>{level.author}</td>\n                    </tr>\n                })}\n            </tbody>\n        </table>\n    </div>\n}\n\nexport default () => {\n    const dispatch = useDispatch();\n    const game = useSelector((state: RootState) => state.game);\n    const ui = useSelector((state: RootState) => state.ui);\n    const [showPopup, setShowPopup] = useState(false);\n    const { levelIndex, levels, positionSaved, frameIndex } = game;\n    const { record } = db;\n    const level = get(levels, [levelIndex]);\n    let lastCmd = CMD.UP;\n    let numShoot = 0;\n    let numMove = 0;\n    map(record, (cmd) => {\n        if (!isDirection(cmd)) {\n            numShoot += 1;\n        } else if (cmd === lastCmd) {\n            numMove += 1;\n        } else {\n            lastCmd = cmd;\n        }\n    });\n\n    const debouncedSetRenderInterval = debounce((renderInterval) => {\n        dispatch(setRenderInterval(renderInterval));\n    }, 500);\n\n    return <div className=\"control-panel\">\n        <div className=\"info\" style={{ position: 'relative' }}>\n            {level && <>\n                <div style={{ \n                    position: 'absolute', \n                    // top: '16%', left: '24%', height: '8%', width: '52%',\n                    top: 39, left: 43, height: 20, width: 93,\n                    textAlign: 'center', color: '#0df90a',\n                }}>{levelIndex + 1}</div>\n                <div style={{ \n                    position: 'absolute', \n                    // top: '39%', left: '5%', height: '8%', width: '90%',\n                    top: 95, left: 9, height: 20, width: 160,\n                    textAlign: 'center', color: '#0df90a', \n                    fontSize: level.levelName.length > 20 ? 11 : 14\n                }}>{level.levelName}</div>\n                <div style={{ \n                    position: 'absolute', \n                    // top: '59%', left: '5%', height: '8%', width: '90%',\n                    top: 144, left: 9, height: 20, width: 160,\n                    textAlign: 'center', color: '#0df90a',\n                }}>{level.author}</div>\n                {/* <div>{level.scoreDifficulty}</div> */}\n                <div style={{ \n                    position: 'absolute',\n                    // top: '82%', left: '11%', height: '8%', width: '32%',\n                    top: 200, left: 20, height: 20, width: 57,\n                    textAlign: 'center', color: '#0df90a',\n                }}>{numMove}</div>\n                <div style={{ \n                    position: 'absolute', \n                    // top: '82%', left: '58%', height: '8%', width: '32%',\n                    top: 200, left: 103, height: 20, width: 57,\n                    textAlign: 'center', color: '#0df90a',\n                }}>{numShoot}</div>\n\n                <div>{}</div>\n            </>}\n        </div>\n        <div className=\"control\">\n            {map([\n                [\n                    { name: 'Undo', cmd: CMD.UNDO, disabled: frameIndex > 0 }, \n                    { name: 'Hint', onClick: () => {\n                        if (level?.hint) {\n                            alert(level?.hint);\n                        }\n                    }},\n                ],\n                [\n                    { name: 'Save', disabled: frameIndex > 0, cmd: CMD.SAVE_POSITION }, \n                    { \n                        name: 'Restore', cmd: CMD.RESTORE_POSITION, \n                        disabled: frameIndex > 0 && !positionSaved \n                    },\n                ],\n                [{ name: 'Restart', cmd: CMD.RESTART }, { name: 'Load Level', onClick: () => {\n                    setShowPopup(true);\n                }}],\n                [{ name: '<< Level', cmd: CMD.PREV_LEVEL }, { name: 'Level >>', cmd: CMD.NEXT_LEVEL }],\n                [\n                    { name: '<< Frame', cmd: CMD.PREV_FRAME }, \n                    { name: 'Frame >>', cmd: CMD.NEXT_FRAME, disabled: frameIndex === 0 }\n                ],\n            ], (row, i) => {\n                return <div key={i}>\n                    {map(row, (\n                        { name, cmd, onClick, disabled }: \n                        { name: string, cmd?: CMD, onClick?: any, disabled?: boolean }, \n                        j\n                    ) => {\n                        return <button key={j} disabled={disabled} onClick={(e) => {\n                            if (onClick) {\n                                onClick(e);\n                            } else if (cmd) {\n                                dispatch(exec(cmd))\n                            }\n                        }}>{name}</button>\n                    })}\n                </div>\n            })}\n            <div style={{ flexDirection: 'column', alignItems: 'flex-start' }}>\n                <div>\n                    <label style={{ flex: 1 }}>speed(0 - 10000): </label>\n                </div>\n                <div>\n                    <input style={{ flex: 3 }} value={ui.renderInterval} \n                        onChange={(e: React.ChangeEvent<HTMLInputElement>) => {\n                            debouncedSetRenderInterval(toNumber(e.target.value));\n                        }}\n                    />\n                    <span>ms</span>\n                </div>\n            </div>\n        </div>\n        {showPopup && <LevelsPopup levels={levels} onClick={(i) => {\n            dispatch(loadLevel(i));\n            setShowPopup(false);\n        }}/>}\n    </div>\n}","import React, { useEffect } from 'react';\nimport { useDispatch } from 'react-redux';\n\nimport './App.css';\nimport { loadLevels } from '../features/game/game';\nimport Board from '../features/game/Board';\nimport MenuBar from '../features/ui/MenuBar';\nimport ControlPanel from '../features/ui/ControlPanel';\n\nconst App: React.FC = () => {\n  const dispatch = useDispatch();\n  useEffect(() => {\n    try {\n      const levels = JSON.parse(localStorage.getItem('levels') ?? '');\n      const levelIndex = JSON.parse(localStorage.getItem('levelIndex') ?? '0');\n      if (levels) {\n        dispatch(loadLevels({ levels, levelIndex }));\n      }\n    } catch (error) {\n      alert(`failed to load levels: ${error}`);\n    }\n  }, [dispatch]);\n\n  return (\n    <div className=\"App\">\n      <MenuBar/>\n      <div className=\"main\">\n        <Board/>\n        <ControlPanel/>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import { combineReducers } from '@reduxjs/toolkit'\n\nimport gameSlice from '../features/game/game';\nimport uiSlice from '../features/ui/ui';\n\nconst rootReducer = combineReducers({\n    game: gameSlice.reducer,\n    ui: uiSlice.reducer,\n});\n\n\nexport type RootState = ReturnType<typeof rootReducer>\n\nexport default rootReducer\n","import { configureStore, Action } from '@reduxjs/toolkit';\nimport { ThunkAction } from 'redux-thunk';\n\nimport rootReducer, { RootState } from './rootReducer';\n\n\nconst store = configureStore({\n    reducer: rootReducer\n});\n\nexport type AppThunk = ThunkAction<void, RootState, null, Action<string>>\nexport default store;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\n\nimport './index.css';\nimport App from './app/App';\nimport * as serviceWorker from './serviceWorker';\nimport store from './app/store';\n\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}